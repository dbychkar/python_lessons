"""
Штаб гражданской обороны Тридесятой области решил обновить план спасения
на случай ядерной атаки. Известно, что все n селений Тридесятой области
находятся вдоль одной прямой дороги. Вдоль дороги также расположены m
бомбоубежищ, в которых жители селений могут укрыться на случай ядерной атаки.
Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
необходимо для каждого селения определить ближайшее к нему бомбоубежище.
Формат ввода
В первой строке вводится число n - количество селений (1 <= n <= 100000).
Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
расстояние от начала дороги до i-го селения. В третьей строке входных данных
задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая
строка содержит m различных целых чисел, i-е из этих чисел задает расстояние
от начала дороги до i-го бомбоубежища. Все расстояния положительны и не
превышают 10⁹. Селение и убежище могут располагаться в одной точке.
Формат вывода
Выведите n чисел - для каждого селения выведите номер ближайшего к нему
бомбоубежища. Бомбоубежища пронумерованы от 1 до m в том порядке, в котором
они заданы во входных данных.
Указание
Создайте список кортежей из пар (позиция селения, его номер в исходном
списке), а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.
Перебирайте селения в порядке возрастания.
Для селения ближайшими могут быть два соседних бомбоубежища,
среди них надо выбрать ближайшее. При переходе к следующему селению не
обязательно искать ближайшее бомбоубежище с самого начала. Его можно искать
начиная с позиции, найденной для предыдущего города.
Для хранения ответа используйте список, где индекс будет номером селения,
а по этому индексу будет запоминаться номер бомбоубежища.
"""


n = int(input())
a = map(int, input().split())
m = int(input())
b = list(map(int, input().split()))

for i in range(len(b)):
    b[i] = [i + 1, b[i]]

b.sort(key=lambda x: x[1])


def find_value(x):
    if (x < b[0][1]):
        return b[0][0]
    if (x > b[-1][1]):
        return b[-1][0]
    l = 0
    r = len(b) - 1
    # b[l][1] < x
    while (r - l > 1):
        m = (r + l) >> 1
        if (b[m][1] < x):
            l = m
        else:
            r = m
    if (x - b[l][1] < b[r][1] - x):
        return b[l][0]
    else:
        return b[r][0]


print(*[find_value(v) for v in a])
